  Homework-8
  DZ-8: Scapy и XSS (Google Gruyere)
  Домашнее задание по дисциплине «Программирование на Python».
  Тема: «Взаимодействие в WWW: взаимодействие с сервисами».

Окружение
  ОС: Windows 11
  Python 3.12.10
  Scapy
  Wireshark (для просмотра pcap)

Браузер (для работы с Google Gruyere и тестовым HTTP‑сайтом)

  Этап 1. Настройка Scapy
Установлен Scapy:

В командной строке ввести:
  pip install scapy
Скрипт запускается от имени администратора, так как для перехвата трафика требуются повышенные права.

Перехваченный трафик сохраняется в файл формата .pcap для анализа в Wireshark.

Основной файл: sniffer_win.py.

  Этап 2. Анализ HTTP‑трафика
  
Скрипт sniffer_win.py выполняет следующие действия:
перехватывает TCP‑трафик, в котором присутствует HTTP;
извлекает из Raw‑части пакетов HTTP‑запросы и ответы;
парсит первую строку HTTP (метод, путь, версия протокола) и заголовки;
выводит разобранную информацию в консоль для оперативного анализа;
сохраняет все перехваченные пакеты в файл traffic_raw.pcap.

Пример использования (PowerShell, запуск от имени администратора):

powershell
python sniffer_win.py
 в это время в браузере открываю HTTP‑сайт BEEWAP
 работаю с сайтом, чтобы сгенерировать HTTP‑трафик
 в консоли вижу вывод скрипта: метод, путь и заголовки HTTP
 затем нажимаю Ctrl+C для остановки перехвата
 в текущей папке появляется файл traffic_raw.pcap
 файл открываю в Wireshark для детального анализа
 Wireshark по фильтру http анализируются:

метод запроса (GET / POST);

URL и параметры;
заголовки (Host, User‑Agent, Cookie и др.);
тело ответа (HTML‑страница и другие данные).
Файл с примером перехваченного трафика: traffic_raw.pcap.

Этап 3. Эксплуатация XSS (Google Gruyere)
Эксплуатация XSS выполнялась через онлайн‑версию Google Gruyere:
https://google-gruyere.appspot.com

Шаги:

В интерфейсе Gruyere открыт раздел работы с фрагментами («Мои фрагменты»).

Создан новый фрагмент с содержимым:

xml
  <script>alert('XSS')</script>
После сохранения фрагмента при его просмотре в браузере появляется всплывающее окно alert('XSS').
Это подтверждает наличие хранимой XSS‑уязвимости (stored XSS) в этой части приложения.

Особенность окружения:
онлайн‑версия Gruyere используется через HTTPS, поэтому трафик между браузером и сервером шифруется;
при перехвате трафика на уровне сети содержимое HTTP не видно в открытом виде, и разобрать его как обычный HTTP‑поток тем же скриптом не удалось;
для демонстрации перехвата и анализа HTTP‑трафика в рамках задания применён отдельный тестовый HTTP‑сайт (BEEWAP), а Gruyere использовался как учебный стенд для демонстрации XSS‑атаки в браузере.
Результат XSS-атаки отображен ввиде изображения, который также прикреплен к домашнему заданию

Этап 4. Анализ результатов
HTTP‑запрос и ответ (пример на тестовом HTTP‑сайте)
В файле traffic_raw.pcap содержится HTTP‑трафик, перехваченный при работе с тестовым сайтом BEEWAP с помощью скрипта sniffer_win.py.

Типичный HTTP‑запрос, который видно в файле и в консоли:

GET /some/path?param=value HTTP/1.1
Host: <host>
User-Agent: <браузер>
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
...
Типичный HTTP‑ответ сервера:

HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: ...
...

<html>...</html>
Скрипт sniffer_win.py выводит ту же информацию в текстовом виде:
определяет, является ли сообщение HTTP‑запросом или ответом, и печатает метод, путь, статус и заголовки.

Как выглядит XSS‑payload на уровне HTTP (по аналогии с Gruyere)
При создании фрагмента в Gruyere XSS‑payload <script>alert('XSS')</script> передаётся как часть пользовательского ввода.
Если представить соответствующий сетевой запрос в виде «сырого» HTTP, он будет иметь вид:

POST /snippets.gtl HTTP/1.1
Host: google-gruyere.appspot.com
Content-Type: application/x-www-form-urlencoded
...

snippet=<script>alert('XSS')</script>
То есть полезная нагрузка XSS передаётся внутри параметра (например, snippet) в теле POST‑запроса.
На стороне сервера содержимое сохраняется и затем отображается в HTML без корректного экранирования.

В HTTP‑ответе сервера (странице со списком фрагментов) эта строка попадает в HTML‑разметку, например:

xml:
<div class="snippet">
  <script>alert('XSS')</script>
</div>
Браузер интерпретирует этот фрагмент как JavaScript‑код, и при загрузке страницы выполняется alert('XSS').

  Отличия обычного HTTP‑трафика от трафика с XSS‑полезной нагрузкой

На уровне HTTP‑запроса:
в обычных запросах параметры содержат только текстовые или числовые значения без HTML/JavaScript;
в запросе с XSS‑нагрузкой в одном из параметров или в теле POST появляется строка, содержащая HTML‑теги и JavaScript, например <script>...</script>.

На уровне HTTP‑ответа:
в безопасном варианте пользовательские данные выводятся в HTML с экранированием, и браузер не воспринимает их как код;
в случае XSS‑уязвимости сервер вставляет пользовательские данные напрямую в HTML‑разметку, что приводит к выполнению встроенного JavaScript‑кода в браузере.

  В рамках данного домашнего задания:

с помощью sniffer_win.py продемонстрирован перехват и анализ HTTP‑трафика: структура запросов и ответов, заголовки, тело сообщения;
с помощью Google Gruyere продемонстрирована эксплуатация XSS‑уязвимости (stored XSS) и показано, как XSS‑полезная нагрузка выглядит и ведёт себя на уровне веб‑приложения и HTML‑ответа;
полученные результаты оформлены в виде скрипта, pcap‑файла и данного описания, которые можно использовать для самопроверки и повторения эксперимента в будущем.


